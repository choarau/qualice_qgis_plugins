# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CreationEtExport
                                 A QGIS plugin
 Ce plugin permet de créer un projet QGIS pré-configuré et d'exporter des illustrations automatiquement.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-07-06
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Mathilde
        email                : mathilde.segaud@ensg.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QFileInfo
from qgis.PyQt.QtGui import QIcon, QColor, QFont
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QPushButton

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .creation_export_dialog import CreationEtExportDialog
import os.path

from .Color import Color
from qgis.core import (
    QgsProject,
    Qgis,
    QgsMapLayer,
    QgsRectangle,
    QgsLayerTree,
    QgsVectorLayer,
    QgsPrintLayout,
    QgsLayoutItemMap,
    QgsLayoutPoint,
    QgsLayoutSize,
    QgsUnitTypes,
    QgsLayoutExporter,
    QgsMapSettings,
    QgsLayoutItemLegend,
    QgsScaleBarSettings,
    QgsLayoutItemScaleBar,
    QgsLayoutItemLabel,
    QgsVectorLayerFeatureCounter,
    

)
from qgis.gui import (
    QgsLayerTreeMapCanvasBridge,
    QgsMessageBar,
    
)
from qgis.utils import iface, Qgis
from io import StringIO, BytesIO

import os
import os.path
from lxml import etree
import xml.etree.ElementTree as ET

class CreationEtExport:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'CreationEtExport_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Creation et export')
        
      
        
        

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('CreationEtExport', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/creation_export/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Créér un projet ou exporter'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Creation et export'),
                action)
            self.iface.removeToolBarIcon(action)



################################CREATION PROJET#####################################################""
   
    ### SELECTION DES DONNEES EN ENTREES ###
    def select_output_project(self):
        """Selection de l'emplacement d'enregistrement du projet"""
        filename, _filter = QFileDialog.getSaveFileName(
            self.dlg, "Emplacement du projet QGIS","",'(*.qgs)')
        self.dlg.lineEdit_6.setText(filename)
    
    def select_input_construction(self):
        """Selection de l'emplacement du dossier chantier"""
        directory_name = QFileDialog.getExistingDirectory(self.dlg, "Dossier du chantier","")
        self.dlg.lineEdit.setText(directory_name)
        self.dlg.lineEdit_6.setText(directory_name+"/3_QUALIF_CALIX/QGIS/"+os.path.basename(directory_name)+".qgs")
        
    def select_input_SHP_Monde(self):
        """Selection de l'emplacement du dossier SHP_Monde"""
        directory_name = QFileDialog.getExistingDirectory(self.dlg,"Dossier SHP Monde","")
        self.dlg.lineEdit_5.setText(directory_name)
    
    def select_input_styles(self):
        """Selection de l'emplacement du dossier style_QGIS"""
        directory_name = QFileDialog.getExistingDirectory(self.dlg,"Dossier Styles QGIS","")
        self.dlg.lineEdit_4.setText(directory_name)
    
    def select_input_DAP(self):
        """Selection de l'emplacement du dossier DAP"""
        directory_name = QFileDialog.getExistingDirectory(self.dlg,"Dossier DAP","")
        self.dlg.lineEdit_2.setText(directory_name)
        
  
    
    ### REMPLISSAGE DU FICHIER_CONFIGURATION_1 ###
        
    ###IMPORT###
    def create_parametersFile_IMPORT(self,tree, root,main_path, type_import,tag ):
       """ Remplis les differentes sous parties de la balise <project_import>
           
           Entree :
               main_path : type str
                   correspond au chemin du dossier necessaire a la recovery du chemin de la couche
               type_import : type str
                   correspond au type d'import : layer ou style
               tag : type str
                   correspond à la balise que l'on veut remplir
       
       """
       if type_import == "layers":
           
           #parcours des sous-balises
           for node in root[2][0].findall(tag):
               #pour chaque sous-balise on ajoute un element path
               relative_path = node.get('path')
               #construction du chemin absolue pour acceder au dossier des couches
               path_1 = os.path.normpath(os.path.join(main_path,relative_path))
               if os.path.exists(path_1):
                   #recovery de la liste des fichiers
                   list_files = os.listdir(path_1)
                   layer_exist = ""
                   #parcours les fichiers
                   for file in list_files:
                       #si le fichier repond aux criteres de la sous-balise :
                       # - creation d'un sous-element path qui contient le chemin absolu de la couche
                       # - remplissage de l'attribut nom de la sous-balise correspondant au nom de la couche (=du fichier)
                       if node.get('filter') in file and node.get('contain')in file:
                           path_2 = etree.SubElement(node, "path")
                           p = os.path.join(path_1,file)
                           path_2.text =  os.path.normpath(p) 
                           layer_exist += path_2.text
                           if "SHP_Monde" in path_2.text:
                              name = file.replace(".shp","")
                           else:
                              name = node.get("contain")
                              name = name.replace(".","")
                           node.set("layer_name",name)
                   if layer_exist=="":
                       root[2][0].remove(node)
                
               else:
                   self.dlg.textBrowser_3.setTextColor(Color.RED.value)
                   self.dlg.textBrowser_3.append("Erreur : le dossier "+path_1+" n'existe pas")
                   iface.messageBar().pushMessage("Erreur","Erreur : le dossier "+path_1+" n'existe pas", level=Qgis.Warning)
                   self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
                       
                       
       else:
           
           for node in root[2][1].findall(tag):
               relative_path = node.get('path')
               path_1 = os.path.normpath(os.path.join(main_path,relative_path))
               list_files = os.listdir(path_1)
               for file in list_files:
                  style = etree.SubElement(node, "style")
                  name = file.replace(".qml","")
                  style.set("style_name",name)
                  style.set("id","")
                  path_2 = etree.SubElement(style, "path")
                  p = os.path.join(path_1,file)
                  path_2.text =  os.path.normpath(p) 
            
    ### PARAMETRES ###        
    def create_parametersFile_PARAMETERS(self,tree, root, path_carto_mondiale,path_dap, path_style, path_construction,path_project, source_satellite_image):
        """ Remplis les differentes sous parties de la balise <project_properties>
            
            Entree :
                path_carto_mondiale : type str
                    correspond au chemin du dossier contenant les couches de la carte mondiale
                path_dap : type str
                    correspond au chemin du dossier des DAP
                path_style : type str
                    correspond au chemin du dossier des styles
                path_construction : type str
                    correspond au chemin du dossier du chantier
                origin_satellite_image : type str
                    correspond a l'origine des images : SPOT ou PHR
        
        """
        tree_path = "/project_creation/project_properties"
        for node in tree.xpath(tree_path+"/name"):
            node.text = os.path.basename(path_project)
        for node in tree.xpath(tree_path+"/path_project"):
            node.text = os.path.normpath(path_project)
        for node in tree.xpath(tree_path+"/construction/path_construction"):
            node.text = os.path.normpath(path_construction)
        if path_style!=False:
            for node in tree.xpath(tree_path+"/other_dir/style_dir"):
                node.text = os.path.normpath(path_style)
        if path_carto_mondiale!=False:
            for node in tree.xpath(tree_path+"/other_dir/worldmap_dir"):
                node.text = os.path.normpath(path_carto_mondiale)
        if path_dap!=False:
            for node in tree.xpath(tree_path+"/other_dir/dap_dir"):
                node.text = os.path.normpath(path_dap)
        for node in tree.xpath(tree_path+"/source_satellite_image"):
            node.text = source_satellite_image
    
    ### RECUPERATION DES DONNEES DU FICHIER CONFIGURATION_RESULTAT_1 ###
            
    def recovery_filename_project(self, root):
        """Recupere le chemin d'acces du projet QGIS """
        filename_project = root[0].find("path_project").text
        return filename_project
    
    def recovery_path_import(self,layer_name, root):
        """Recupere le chemin d'une couche grace à son nom
        
        Entree : 
            layer_name : type str
            correspond à l'attribut layer_name pour les parties structure et import
       
        Sortie :
            path : type str
            correspond au chemin absolu de la couche
        """
        for layer in root[2][0].getchildren():
            if layer.get("layer_name")==layer_name:
                path = layer.find('path').text
                return path

    def recovery_path_style(self,style_name, root):
        """Recupere le chemin d'un style grace à son nom
        
        Entree : 
            style_name : type str
            correspond à l'attribut style_name pour les parties structure et import
       
        Sortie :
            path : type str
            correspond au chemin absolu du style
        """
        for style_gr in root[2][1].getchildren():
            for style in style_gr.getchildren():
                if style.get("style_name")==style_name:
                    path = style.find('path').text
                    return path
     
        
    def recovery_source_img_checkbox(self):
        """Verifie si la checkbox Pleiade a ete coche"""
        if self.dlg.checkBox.isChecked()==True:
            return self.dlg.checkBox.text()
        else: 
            return False
        
    def recovery_source_img_checkbox2(self):
        """Verifie si la checkbox Spot a ete coche"""
        if self.dlg.checkBox_2.isChecked()==True:
            return self.dlg.checkBox_2.text()
        else: 
            return False
        
    def recovery_source_img(self):
        """Verifie quelle source satellite image a ete choisie par l'utilisateur"""
        checkbox_1 = self.recovery_source_img_checkbox()
        checkbox_2 = self.recovery_source_img_checkbox2()
        if checkbox_1 != False and checkbox_2 != False: 
            self.dlg.textBrowser_3.append( "Sources images satellites : PLEIADE ET SPOT")
            return "PLEIADE/SPOT"
        elif checkbox_1 == False and checkbox_2 != False:
            self.dlg.textBrowser_3.append( "Source images satellites : SPOT")
            return "SPOT"
        elif checkbox_1 != False and checkbox_2 == False:
            self.dlg.textBrowser_3.append("Source images satellites : PLEIADE")
            return "PLEIADE"
        else:
            iface.messageBar().pushMessage("Erreur","Vous n'avez cocher aucune source satellite", level=Qgis.Warning)
            self.dlg.textBrowser_3.setTextColor(Color.RED.value)
            self.dlg.textBrowser_3.append( "Erreur : aucune sources satellite n'a été choisi")
            self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
            return "PLEIADE/SPOT"
            

    def pleiade_spot(self,root,group, layer,name, layer_name):
        """Recuperation le nom de la source des images"""
        layer_source = root[0].find('source_satellite_image')
        source_img = layer_source.text
        if source_img in name or source_img=="PLEIADE/SPOT":
            return self.recovery_path_import(layer_name, root)
        else:
            layer.getparent().remove(layer)
           
            return ""
        
    def testExist(self, name, path):
        if not path:
            self.dlg.textBrowser_3.setTextColor(Color.RED.value)
            self.dlg.textBrowser_3.append("Erreur : "+name+" n'a pas été chargé")
            self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
            
            
    def loading_layers(self, tree, root, project, progressBar):
        """Chargement des couches et application des styles
        
        Entree:
            tree : type lxml.etree
                correspond à l'arborescence du fichier .xml
            root : type root
                correspond au rootage pour passer les noeuds/balises du fichier .xml
            project : type QgsProject
                correspond au projet Qgis chargé dans QGIS
            progressBar : type QgsProgressBar
                correspond à la barre de chargement
        """
        root_proj = project.layerTreeRoot()
        value_1 = 50/len(root[1].findall('layer_group'))
        value = 50
        for group in root[1].findall('layer_group'):
            groupe = root_proj.addGroup(group.get('value'))
            #creation du groupe
            if group.getchildren()!= []:
                #si le groupe possede des sous-element
                
                for layer in group.getchildren():
                    #recovery pour toutes les couches 
                    layer_name = layer.get('layer_name')
                    style_name = layer.get('style_name')
                    path_layer = self.recovery_path_import(layer_name, root)
                    path_style = self.recovery_path_style(style_name, root)
                    self.testExist(style_name, path_style)
                    self.testExist(layer_name, path_layer)
                    if not path_layer:
                        pass
                    else:
                        if os.path.exists(path_layer):
                            name = layer.find('name').text
                            if "PLEIADE" in name or "SPOT" in name:
                                #self.pleiade_spot(root, group, layer ,name)
                                path_layer = self.pleiade_spot(root, group, layer ,name, layer_name)
                            if path_layer=="":
                                pass
                            else:
                                layer = QgsVectorLayer(path_layer,name) 
                                layer.loadNamedStyle(path_style)
                                project.addMapLayer(layer, False)
                                groupe.addLayer(layer)   
                                iface.mapCanvas().refresh()
                                self.dlg.textBrowser_3.append(name+" chargée")
                            
                    value += value_1
                    progressBar.setValue(value)
        
        
    def data_verification_dir_construction(self, data):
        """Verification du bon remplissage du champ Dossier du chantier de l'interface
         
        Entree:
            data : type str
            correspond au chemin d'accès du chantier
            
        Sortie:
            renvoie une erreur critique si les conditions ne sont pas remplies avec un message
        """
        if not data:
            iface.messageBar().pushMessage("Erreur", "Le champ du dossier de chantier est vide, il n'a pas été rempli", level=Qgis.Critical)
        else:
            if os.path.exists(data):
                self.dlg.textBrowser_3.append("Le chemin d'accès "+data+" est valide")
            else:
                iface.messageBar().pushMessage("Erreur", "Le chemin d'accès du dossier du chantier n'existe pas", level=Qgis.Critical)
                self.dlg.textBrowser_3.setTextColor(Color.RED.value)
                self.dlg.textBrowser_3.append("Erreur : le chemin d'accès du dossier chantier n'existe pas")
                self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
                
    def data_verification_dir(self, data):
        """Verification du bon remplissage des autres champs de l'interface
         
        Entree:
            data : type str
            correspond au chemin d'accès du dossier correspondant
            
        Sortie:
            renvoie une erreur critique si les conditions ne sont pas remplies avec un message
        """
        if not data[1]:
            text =  "Le champ du dossier "+data[0]+" est vide, il n'a pas été rempli"
            iface.messageBar().pushMessage("Erreur",text, level=Qgis.Warning)
            self.dlg.textBrowser_3.setTextColor(Color.RED.value)
            self.dlg.textBrowser_3.append( "Erreur : le champ du dossier "+data[0]+" est vide")
            self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
            return False
        else:
            if os.path.exists(data[1]):
                self.dlg.textBrowser_3.append("Le chemin d'accès "+data[0]+" est valide")
                return True
            else:
                self.dlg.textBrowser_3.setTextColor(Color.RED.value)
                self.dlg.textBrowser_3.append( "Erreur : le chemin d'accès du dossier "+os.path.basename(data[1])+" n'existe pas")
                self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
                return False
            
    def run_1(self):
        """Moteur de la partie creation d'un projet du plugin"""
        #progresse barre
        progressBar = self.dlg.progressBar
        value = 0
        progressBar.setValue(value)
        
        ### REMPLISSAGE DU FICHIER_CONFIGURATION_1 ###
        #initialisation de l'arbre du fichier .xml
        tree = etree.parse(os.path.join(self.plugin_dir,"fichier_configuration_1.xml"))
        root = tree.getroot()
    
        #parametres qui seront fournis par l'interface
        path_project = ["fichier du projet", os.path.dirname(self.dlg.lineEdit_6.text())]
        path_carto_mondiale = ["SHP_Monde",self.dlg.lineEdit_5.text()]
        path_dap = ["données d'appui du chantier",self.dlg.lineEdit_2.text()]
        path_style =["Styles_QGIS",self.dlg.lineEdit_4.text()]
        path_construction = self.dlg.lineEdit.text()
        
        #definition des couleurs des messages
       
        
        #Verifications des entrees de l'utilisateur
        
        self.dlg.textBrowser_3.append( "CREATION D'UN PROJET")
        self.dlg.textBrowser_3.setTextColor(Color.BLUE.value)
        self.dlg.textBrowser_3.append( "\nVérifications des données entrées :")
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
        self.data_verification_dir_construction(path_construction)
        source_satellite_image = self.recovery_source_img()

       
        if self.data_verification_dir(path_carto_mondiale)==True:
            #Chemin valide = completion de l'import valide
            self.create_parametersFile_IMPORT(tree, root, path_carto_mondiale[1],"layers","layer_background" )
        else:
            path_carto_mondiale[1]=False
        if self.data_verification_dir(path_dap)==True:
            #Chemin valide = completion de l'import valide
            self.create_parametersFile_IMPORT(tree, root, path_dap[1],"layers","layer_DAP" )
        else:
            path_dap[1]=False
        if self.data_verification_dir(path_style)==True:
            #Chemin valide = completion de l'import valide
            self.create_parametersFile_IMPORT(tree, root, path_style[1],"style", "styles" )
        elif self.data_verification_dir(path_style)==False:
            path_style[1]=False
        if self.data_verification_dir(path_project)==True:
            #Chemin valide = completion de l'import valide
            path_project = self.dlg.lineEdit_6.text()
        elif self.data_verification_dir(path_project)==False:
            #Sinon, le projet est enregistre automatiquement à un endroit précis dans le dossier du chantier
            name_project = os.path.basename(path_construction)
            path_proj_relative= os.path.join("3_QUALIF_CALIX/QGIS", name_project)+".qgs"
            path_project = os.path.join(path_construction,path_proj_relative)
            
        value = 15
        progressBar.setValue(value)
        #partie parametres du projet
        self.create_parametersFile_PARAMETERS(tree, root, path_carto_mondiale[1],path_dap[1],path_style[1], path_construction, path_project,source_satellite_image)
        value = 30
        progressBar.setValue(value)
        #partie import du projet dossier chantier
        self.create_parametersFile_IMPORT(tree, root, path_construction,"layers", "layer" )
        value = 45
        progressBar.setValue(value)
        #enregistrement sous un nouveau fichier parametre FIHCIER_CONFIGURATION_RESULTAT_1 
        name_project = os.path.basename(path_project).replace(".qgs","")
        tree.write(os.path.normpath(os.path.join(self.plugin_dir,"fichier_configuration_resultat_1.xml")))
        tree.write(os.path.join(os.path.dirname(path_project),"fichier_configuration_creation_projet_"+name_project+".xml"))
        self.dlg.textBrowser_3.setTextColor(Color.GREEN.value)
        self.dlg.textBrowser_3.append( "\nLe fichier_configuration_creation_projet est disponible dans le dossier "+os.path.dirname(path_project)+"\n")
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
        ### LECTURE DU FICHIER_CONFIGURATION_RESULTAT_1 ###
        tree = etree.parse(os.path.normpath(os.path.join(self.plugin_dir,"fichier_configuration_resultat_1.xml")))
        root = tree.getroot()
        
        #creation projet QGIS
      
        project = QgsProject.instance()
        if Qgis.QGIS_VERSION_INT==int('31006'):
            color = QColor(166, 206, 227,255) #paramètre couleur fond projet en bleu
            project.setBackgroundColor(color)
        value = 50
        progressBar.setValue(value)
        #remplissage du journal de message du plugin
        self.dlg.textBrowser_3.setTextColor(Color.BLUE.value)
        self.dlg.textBrowser_3.append( "\nChargement des couches avec leur style :")
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
        self.loading_layers(tree, root, project,progressBar)
        
        #zoom sur l'reach du chantier
        for lyr in project.mapLayers().values():
            if lyr.name() == "reach_PU_CHANTIER":
                iface.mapCanvas().setExtent(lyr.extent())
        
        #recuperation du chemin d'enregistrement du projet dans le FICHIER_CONFIGURATION_RESULTAT_1
        filename_project = self.recovery_filename_project(root)
        
        #sauvegarde du projet
        if not os.path.exists(os.path.dirname(filename_project)):
                os.makedirs(os.path.dirname(filename_project))
        project.write(filename_project)
        value = 100
        progressBar.setValue(value)
        
        self.dlg.textBrowser_3.setTextColor(Color.GREEN.value)
        self.dlg.textBrowser_3.append( "\nLe projet est sauvegardé à l'emplacement :"+filename_project)
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
        pass
    
###############################EXPORT DES ILLUSTRATIONS#################################################
    ### SELECTION DES DONNEES EN ENTREE ###
    def select_output_images(self):
        """Selection de l'emplacement du dossier illustrations"""
        directory_name = QFileDialog.getExistingDirectory(self.dlg)
        self.dlg.lineEdit_3.setText(directory_name)
        
    def filling_title(self, root):
        """Verifie si la checkbox Titre a ete coche"""
        if self.dlg.checkBox_3.isChecked()==True:
            for group in root[1].findall('image'):
                group.find('title').set("exist","yes")
            self.dlg.textBrowser_3.append("AJOUT d'un titre à chaque illustration")
        else: 
            for group in root[1].findall('image'):
                group.find('title').set("exist","no")     
            self.dlg.textBrowser_3.append("ABSENCE d'un titre à chaque illustration")
                
    def filling_legende(self, root):
        """Verifie si la checkbox Legende Spot a ete coche"""
        if self.dlg.checkBox_4.isChecked()==True:
            for group in root[1].findall('image'):
                group.find('legende').set("exist","yes")
            self.dlg.textBrowser_3.append("AJOUT d'une légende à chaque illustration")
        else: 
            for group in root[1].findall('image'):
                group.find('legende').set("exist","no")  
            self.dlg.textBrowser_3.append("ABSENCE d'une légende à chaque illustration")
    
    def filling_scale(self, root):
        """Verifie si la checkbox Echelle a ete coche"""
        if self.dlg.checkBox_5.isChecked()==True:
            for group in root[1].findall('image'):
                group.find('scale').set("exist","yes")
            self.dlg.textBrowser_3.append("AJOUT d'une échelle à chaque illustration")
        else: 
            for group in root[1].findall('image'):
                group.find('scale').set("exist","no")  
            self.dlg.textBrowser_3.append("ABSENCE d'une échelle à chaque illustration")
            
    def find_grid(self,root, image):
        """Recupere la plus grande emprise des couches de l'illustration"""
        map_layer = image.find('map')
        area = 0
        reach = ""
        for layer in map_layer.findall('layer'):
            mapLayers = QgsProject.instance().mapLayersByName(layer.get('name'))
            if mapLayers!=[] and layer.get('name')!= "CARTO_MONDIALE" and layer.get('name')!= "ZONES_ARC" and layer.get('name')!= "ZONES_ARC_PU_CHANTIER" :
                layer_reach = QgsProject.instance().mapLayersByName(layer.get('name'))[0]  
                area_layer =  layer_reach.extent().area()
                if area_layer>area:
                    area = area_layer
                    reach = layer_reach.extent()
        return reach
     
    def filling_size_image(self, root):
        """Remplis la balise size du fichier configuration pour connaitre l'emprise de l'illustration"""
        for image in root[1].findall('image'):
            map_layer = image.find('map')
            reach = self.find_grid(root,image)
            size = map_layer.find('size')
            size.text = reach.toString() 
        return 
    
    
    def getMapLayers(self, image):
        """Recupere la liste des couches de l'illustration"""
        map_layer = image.find('map')
        layers = []
        for layer in map_layer.findall('layer'):
             if QgsProject.instance().mapLayersByName(layer.get('name'))!=[]:
                 layers.append(QgsProject.instance().mapLayersByName(layer.get('name'))[0])   
                 self.dlg.textBrowser_3.append(layer.get('name')+" CHARGEE")
        return layers
    
    def legende(self, layout, map):
        """Ajout d'une legende a l'illustration"""
        legend = QgsLayoutItemLegend(layout)
        legend.setLinkedMap(map) # pass a QgsLayoutItemMap object
        legend.setLegendFilterByMapEnabled(True)
        legend.refresh()     
        layout.addLayoutItem(legend)
        legend.attemptMove(QgsLayoutPoint(200,100,QgsUnitTypes.LayoutMillimeters))
        legend.attemptResize(QgsLayoutSize(5,5,QgsUnitTypes.LayoutMillimeters))
    
    def title(self, layout,layoutName, map):
        """Ajout d'un titre a l'illustration"""
        title = QgsLayoutItemLabel(layout)
        title.setText(layoutName)
        title.setFont(QFont('Arial',16))
        title.adjustSizeToText()
        layout.addLayoutItem(title) # add the title to the layout
        title.attemptMove(QgsLayoutPoint(100,5,QgsUnitTypes.LayoutMillimeters))
    
    def scalebar(self, layout, map):
        """Ajout d'une echelle a l'illustration"""
        scalebar = QgsLayoutItemScaleBar(layout)
        
        scalebar.setStyle('Line Ticks Up') # let's people choose in the menu of the plugin for the next version
        
        scalebar.setUnits(QgsUnitTypes.DistanceKilometers)
        scalebar.setNumberOfSegments(4)
        scalebar.setNumberOfSegmentsLeft(0)
        scalebar.setUnitsPerSegment(150)
        scalebar.setLinkedMap(map)
        scalebar.setUnitLabel('km')
        scalebar.setFont(QFont('Arial',14))
       
        scalebar.update()
        layout.addLayoutItem(scalebar) # add the scalebar to the layout
        scalebar.attemptMove(QgsLayoutPoint(190,190,QgsUnitTypes.LayoutMillimeters))
    
    def export(self, root, path_img, progressBar):
        """Verifie quelle source satellite image a ete choisie par l'utilisateur"""
        
        #initialisation du projet ouvert/cree
        project = QgsProject().instance()
    
        #creation d'un manager de mise en page
        manager = project.layoutManager()
        #parcours les illustrations
        value_1 = 50/len(root[1].findall('image'))
        value = 50
        for image in root[1].findall('image'):
            filename = image.find('filename').text
            layoutName = image.find('title').text
            layouts_list = manager.printLayouts()
            #supprime la mise en page si elle existe deja
            for layout in layouts_list:
                if layout.name() == layoutName:
                    manager.removeLayout(layout)
                    
            #creer la mise en page
            layout = QgsPrintLayout(project)
            layout.initializeDefaults()
            layout.setName(layoutName)
            
            #ajoute la mise en page à la liste des mises en page
            manager.addLayout(layout)
            
            #creation d'un emplacement carte dans la mise en page
            map = QgsLayoutItemMap(layout)
            map.setRect(20,20,20,20)
            
            #recuperation des couches pour l'illustration
            layers = self.getMapLayers(image)
           
                   
            #configuration de l'emplacement carte
            ms = QgsMapSettings()
            #ajout des couches à la carte
            ms.setLayers(layers) # set layers to be mapped
            map.setLayers(layers)
            #configurations :
            rect = QgsRectangle(ms.fullExtent())
            rect.scale(1.0)
            color = QColor(166, 206, 227,255)
            
            map_layer = image.find('map')
            #pour l'reach de l'image
            if map_layer.find('size').text!='Empty':
                mini, maxi = map_layer.find('size').text.split(":")
                xmin, ymin = mini.split(",")
                xmax, ymax = maxi.split(",")
                reach = QgsRectangle(float(xmin)-2.0,float(ymin)-2.0,float(xmax)+2.0,float(ymax)+2.0)
         
                ms.setExtent(reach)
                ms.setBackgroundColor(color)
                map.setExtent(reach)
            
            #ajout de la carte à la mise en page
            layout.addLayoutItem(map) # add map to the layout
            
            map.attemptMove(QgsLayoutPoint(0,0,QgsUnitTypes.LayoutMillimeters))
            map.attemptResize(QgsLayoutSize(220,210,QgsUnitTypes.LayoutMillimeters))
          
            #ajout legende
            if image.find('legende').get('exist')=="yes":
                self.legende(layout, map)
            
            #ajout d'un titre 
            if image.find('title').get('exist')=="yes":
                self.title(layout,layoutName, map)
            
            #ajout d'une échelle
            if image.find('scale').get('exist')=="yes":
                self.scalebar(layout, map)
        
            
            # base_path = os.path.join(QgsProject.instance().homePath())
            pdf_path = os.path.join(path_img, filename+".png")

            exporter = QgsLayoutExporter(layout)
            exporter.exportToImage(pdf_path, QgsLayoutExporter.ImageExportSettings())
            for layer in layers:
                iface.setActiveLayer(layer)
            self.dlg.textBrowser_3.append("\n"+filename+" exportée")
            value+=value_1
            progressBar.setValue(value)
            
    ### REMPLISSAGE DU FICHIER_CONIFGURATION_2 ###
    
    def create_configuration_2_PARAMETERS(self, tree, root, name_project, path_project, path_img):
        tree_path = "/export_images/properties"
        for node in tree.xpath(tree_path+"/name_project"):
            node.text = os.path.basename(path_project)
        for node in tree.xpath(tree_path+"/path_project"):
            node.text = os.path.normpath(path_project)
        for node in tree.xpath(tree_path+"/path"):
            node.text = os.path.normpath(path_img)
            
      
    def run_2(self):
        
        #progresse barre
        progressBar = self.dlg.progressBar_2
        value = 0
        progressBar.setValue(value)
       
        """PARTIE 2 : EXPORT DES ILLUSTRATIONS"""
        ### REMPLISSAGE DU FICHIER_CONFIGURATION_2 ###
        #initialisation de l'arbre du fichier .xml
        tree = etree.parse(os.path.join(self.plugin_dir,"fichier_configuration_2.xml"))
        root = tree.getroot()
       
        
        #remplissage du journal de messages du plugin
        #definition des couleurs des messages
        
        
        #Verifications des entrees de l'utilisateur
  
        self.dlg.textBrowser_3.append( "\nEXPORT DES ILLUSTRATIONS")
     
        self.dlg.textBrowser_3.setTextColor(Color.BLUE.value)
        self.dlg.textBrowser_3.append( "\nVérifications des données entrées :")
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
    
        
        #verifications des entrees de l'utilisateur
        path_img = ["des illustrations", self.dlg.lineEdit_3.text()]
        self.filling_title( root)
        self.filling_legende( root)
        self.filling_scale(root)
        value = 15
        progressBar.setValue(value)
        name_project = os.path.basename(QgsProject.instance().fileName()).replace(".qgs","")
        path_project = QgsProject.instance().fileName()
        if self.data_verification_dir(path_img)==True:
            #Chemin valide = completion de l'import valide
            self.create_configuration_2_PARAMETERS(tree, root, name_project, path_project, path_img[1])
            path_img = path_img[1]
        else : 
            if "3_QUALIF_CALIX" in path_project:
                path_img = os.path.normpath(os.path.join(os.path.dirname(os.path.dirname(path_project)), "ILLUSTRATIONS"))
            else:
                path_img = os.path.normpath(os.path.join(os.path.dirname(path_project), "ILLUSTRATIONS"+name_project))
                if not os.path.exists(path_img):
                    os.makedirs(path_img)
            
            self.create_configuration_2_PARAMETERS(tree, root, name_project, path_project, path_img)
        
        self.filling_size_image(root)
        #enregistrement sous un nouveau fichier parametre FIHCIER_CONFIGURATION_RESULTAT_2 
        tree.write(os.path.join(self.plugin_dir,"fichier_configuration_resultat_2.xml"))
        tree.write(os.path.join(path_img,"fichier_configuration_export_"+name_project+".xml"))
        value = 50
        progressBar.setValue(value)
        #messages
        self.dlg.textBrowser_3.setTextColor(Color.GREEN.value)
        self.dlg.textBrowser_3.append( "\nLe fichier_configuration_export est disponible dans le dossier "+path_img)
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
        
        ### LECTURE DU FICHIER_CONFIGURATION_2 ###
        self.dlg.textBrowser_3.setTextColor(Color.BLUE.value)
        self.dlg.textBrowser_3.append( "\nExport des illustrations :")
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
        self.export(root, path_img, progressBar)
        self.dlg.textBrowser_3.setTextColor(Color.GREEN.value)
        self.dlg.textBrowser_3.append( "\nLes illustrations sont disponibles dans le dossier "+path_img)
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
    
        
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = CreationEtExportDialog()
            ###PREMIERE PARTIE DU PLUGIN : CREATION D'UN PROJET###
            self.dlg.pushButton.clicked.connect(self.select_input_construction)
            self.dlg.pushButton_7.clicked.connect(self.select_output_project)
            self.dlg.pushButton_1.clicked.connect(self.select_input_DAP)
            self.dlg.pushButton_5.clicked.connect(self.select_input_SHP_Monde)
            self.dlg.pushButton_6.clicked.connect(self.select_input_styles)
            
            self.dlg.pushButton_3.clicked.connect(self.run_1)
            ###DEUXIEME PARTIE DU PLUGIN : EXPORT DES ILLUSTRATIONS###
            #pre-remplissage de la zone texte export
            name_project = os.path.basename(QgsProject.instance().fileName()).replace(".qgs","")
            path_project = os.path.normpath(os.path.join(os.path.dirname(QgsProject.instance().fileName()),name_project+"_ILLUSTRATIONS"))
           
            self.dlg.lineEdit_3.setText(path_project)
            self.dlg.pushButton_2.clicked.connect(self.select_output_images)
            self.dlg.pushButton_4.clicked.connect(self.run_2)
        # show the dialog
        self.dlg.show()
       