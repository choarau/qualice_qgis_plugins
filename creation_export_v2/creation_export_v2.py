# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CreationExportV2
                                 A QGIS plugin
 Ce plugin créé un projet QGIS et exporte des illustrations automatiquement à partir de fichiers de configuration
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-07-17
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Mathilde S
        email                : mathilde.segaud@ensg.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QFileInfo
from qgis.PyQt.QtGui import QIcon, QColor, QFont
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QPushButton


from .Color import Color
from qgis.core import (
    QgsProject,
    Qgis,
    QgsMapLayer,
    QgsRectangle,
    QgsLayerTree,
    QgsVectorLayer,
    QgsPrintLayout,
    QgsLayoutItemMap,
    QgsLayoutPoint,
    QgsLayoutSize,
    QgsUnitTypes,
    QgsLayoutExporter,
    QgsMapSettings,
    QgsLayoutItemLegend,
    QgsScaleBarSettings,
    QgsLayoutItemScaleBar,
    QgsLayoutItemLabel,
    

)
from qgis.gui import (
    QgsLayerTreeMapCanvasBridge,
    QgsMessageBar,
    
)
from qgis.utils import iface, Qgis
from io import StringIO, BytesIO

import os
import os.path
from lxml import etree
import xml.etree.ElementTree as ET
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .creation_export_v2_dialog import CreationExportV2Dialog
import os.path


class CreationExportV2:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'CreationExportV2_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Creation et Export V2')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('CreationExportV2', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/creation_export_v2/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Creation et Export V2'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Creation et Export V2'),
                action)
            self.iface.removeToolBarIcon(action)


   ################################CREATION PROJET#####################################################""
    ###SELECTION DU FICHIER DE CONFIGURATION###
    
    def select_input_fichier_configuration_1(self):
        fileconfig, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Fichier de configuration création d'un projet","",'(*.xml)')
        self.dlg.lineEdit.setText(fileconfig)
        
    def select_output_project(self):
        filename, _filter = QFileDialog.getSaveFileName(
            self.dlg, "Emplacement du projet QGIS","",'(*.qgs)')
        self.dlg.lineEdit_1.setText(filename)
        
        
    def recovery_filename_project(self, root):
        """Recupere le chemin d'acces du projet QGIS """
        filename_project = root[0].find("path_project").text
        if filename_project=="":
            filename_project = self.dlg.lineEdit_1.text
        return filename_project

    def recovery_path_construction(self,root):
        path_construction = root[0].find("construction").find("path_construction").text
        self.data_verification_dir_construction(path_construction)
        if self.data_verification_dir_construction(path_construction)==True:
            return path_construction
        else:
            self.dlg.textBrowser_3.append("Erreur : dossier chantier NON VALIDE")
            return False
    def recovery_path_styleQGIS(self,root):
        path_style = root[0].find("other_dir").find("style_dir").text
        self.data_verification_dir(path_style)
        if self.data_verification_dir(path_style)==True:
            return path_style
        else:
            self.dlg.textBrowser_3.append("Erreur : dossier Styles_QGIS est NON VALIDE")
            return False
    def recovery_path_SHP_Monde(self,root):
        path_SHP_Monde = root[0].find("other_dir").find("worldmap_dir").text
        self.data_verification_dir(path_SHP_Monde)
        if self.data_verification_dir(path_SHP_Monde)==True:
            return path_SHP_Monde
        else:
            self.dlg.textBrowser_3.append("Erreur : dossier SHP_Monde est NON VALIDE")
            return False
    def recovery_path_SHP_DAP(self,root):
        path_DAP = root[0].find("other_dir").find("dap_dir").text
        self.data_verification_dir(path_DAP)
        if self.data_verification_dir(path_DAP)==True:
            return path_DAP
        else:
            self.dlg.textBrowser_3.append("Erreur : dossier DAP est NON VALIDE")
            return False
    ### REMPLISSAGE DU FICHIER_CONFIGURATION_1 ###
        
    ###IMPORT###
    def create_parametersFile_IMPORT(self,tree, root,main_path, type_import,tag ):
        """ Remplis les differentes sous parties de la balise <project_import>
            
            Entree :
                main_path : type str
                    correspond au chemin du dossier necessaire a la recovery du chemin de la couche
                type_import : type str
                    correspond au type d'import : layer ou style
                tag : type str
                    correspond à la balise que l'on veut remplir
        
        """
        if type_import == "layers":
            
            #parcours des sous-balises
            for node in root[2][0].findall(tag):
                #pour chaque sous-balise on ajoute un element path
                relative_path = node.get('path')
                #construction du chemin absolue pour acceder au dossier des couches
                path_1 = os.path.normpath(os.path.join(main_path,relative_path))
                if os.path.exists(path_1):
                    #recovery de la liste des fichiers
                    list_files = os.listdir(path_1)
                    layer_exist = ""
                    #parcours les fichiers
                    for file in list_files:
                        #si le fichier repond aux criteres de la sous-balise :
                        # - creation d'un sous-element path qui contient le chemin absolu de la couche
                        # - remplissage de l'attribut nom de la sous-balise correspondant au nom de la couche (=du fichier)
                        if node.get('filter') in file and node.get('contain')in file:
                            path_2 = etree.SubElement(node, "path")
                            p = os.path.join(path_1,file)
                            path_2.text =  os.path.normpath(p) 
                            layer_exist += path_2.text
                            if "SHP_Monde" in path_2.text:
                               name = file.replace(".shp","")
                            else:
                               name = node.get("contain")
                               name = name.replace(".","")
                            node.set("layer_name",name)
                    if layer_exist=="":
                        root[2][0].remove(node)
                 
                else:
                    self.dlg.textBrowser_3.setTextColor(Color.RED.value)
                    self.dlg.textBrowser_3.append("Erreur : le dossier "+path_1+" n'existe pas")
                    iface.messageBar().pushMessage("Erreur","Erreur : le dossier "+path_1+" n'existe pas", level=Qgis.Warning)
                    self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
                        
                        
        else:
            
            for node in root[2][1].findall(tag):
                relative_path = node.get('path')
                path_1 = os.path.normpath(os.path.join(main_path,relative_path))
                list_files = os.listdir(path_1)
                for file in list_files:
                   style = etree.SubElement(node, "style")
                   name = file.replace(".qml","")
                   style.set("style_name",name)
                   style.set("id","")
                   path_2 = etree.SubElement(style, "path")
                   p = os.path.join(path_1,file)
                   path_2.text =  os.path.normpath(p) 
            
    ### PARAMETRES ###        
    def create_parametersFile_PARAMETERS(self,tree, root, path_carto_mondiale,path_dap, path_style, path_construction,path_project, source_satellite_image):
        """ Remplis les differentes sous parties de la balise <project_properties>
            
            Entree :
                path_carto_mondiale : type str
                    correspond au chemin du dossier contenant les couches de la carte mondiale
                path_dap : type str
                    correspond au chemin du dossier des DAP
                path_style : type str
                    correspond au chemin du dossier des styles
                path_construction : type str
                    correspond au chemin du dossier du chantier
                origin_satellite_image : type str
                    correspond a l'origine des images : SPOT ou PHR
        
        """
        tree_path = "/project_creation/project_properties"
        for node in tree.xpath(tree_path+"/name"):
            node.text = os.path.basename(path_project)
        for node in tree.xpath(tree_path+"/path_project"):
            node.text = os.path.normpath(path_project)
        for node in tree.xpath(tree_path+"/construction/path_construction"):
            node.text = os.path.normpath(path_construction)
        if path_style!=False:
            for node in tree.xpath(tree_path+"/other_dir/style_dir"):
                node.text = os.path.normpath(path_style)
        if path_carto_mondiale!=False:
            for node in tree.xpath(tree_path+"/other_dir/worldmap_dir"):
                node.text = os.path.normpath(path_carto_mondiale)
        if path_dap!=False:
            for node in tree.xpath(tree_path+"/other_dir/dap_dir"):
                node.text = os.path.normpath(path_dap)
        for node in tree.xpath(tree_path+"/source_satellite_image"):
            node.text = source_satellite_image
    ### RECUPERATION DES DONNEES DU FICHIER CONFIGURATION_RESULTAT_1 ###
            
   
        
    def recovery_path_import(self,layer_name, root):
        """Recupere le chemin d'une couche grace à son nom
        
        Entree : 
            layer_name : type str
            correspond à l'attribut layer_name pour les parties structure et import
       
        Sortie :
            path : type str
            correspond au chemin absolu de la couche
        """
        for layer in root[2][0].getchildren():
            if layer.get("layer_name")==layer_name:
                path = layer.find('path').text
                return path

    def recovery_path_style(self, style_name,root):
        """Recupere le chemin d'un style grace à son nom
        
        Entree : 
            style_name : type str
            correspond à l'attribut style_name pour les parties structure et import
       
        Sortie :
            path : type str
            correspond au chemin absolu du style
        """
        for style_gr in root[2][1].getchildren():
            for style in style_gr.getchildren():
                if style.get("style_name")==style_name:
                    path = style.find('path').text
                    return path
     
            

    def pleiade_spot(self,root,group, layer,name, layer_name):
        """Recuperation le nom de la source des images"""
        layer_source = root[0].find('source_satellite_image')
        source_img = layer_source.text
        if source_img in name or source_img=="PLEIADE/SPOT":
            return self.recovery_path_import(layer_name, root)
        else:
            layer.getparent().remove(layer)
           
            return ""
        
    def testExist(self, name, path):
        if not path:
            self.dlg.textBrowser_3.setTextColor(Color.RED.value)
            self.dlg.textBrowser_3.append("Erreur : "+name+" n'a pas été chargé")
            self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
            
            
    def loading_layers(self, tree, root, project, progressBar):
        """Chargement des couches et application des styles
        
        Entree:
            tree : type lxml.etree
                correspond à l'arborescence du fichier .xml
            root : type root
                correspond au rootage pour passer les noeuds/balises du fichier .xml
            project : type QgsProject
                correspond au projet Qgis chargé dans QGIS
            progressBar : type QgsProgressBar
                correspond à la barre de chargement
        """
        root_proj = project.layerTreeRoot()
        value_1 = 50/len(root[1].findall('layer_group'))
        value = 50
        for group in root[1].findall('layer_group'):
            groupe = root_proj.addGroup(group.get('value'))
            #creation du groupe
            if group.getchildren()!= []:
                #si le groupe possede des sous-element
                
                for layer in group.getchildren():
                    #recovery pour toutes les couches 
                    layer_name = layer.get('layer_name')
                    style_name = layer.get('style_name')
                    path_layer = self.recovery_path_import(layer_name, root)
                    path_style = self.recovery_path_style(style_name, root)
                    self.testExist(style_name, path_style)
                    self.testExist(layer_name, path_layer)
                    if not path_layer:
                        pass
                    else:
                        if os.path.exists(path_layer):
                            name = layer.find('name').text
                            if "PLEIADE" in name or "SPOT" in name:
                                #self.pleiade_spot(root, group, layer ,name)
                                path_layer = self.pleiade_spot(root, group, layer ,name, layer_name)
                            if path_layer=="":
                                pass
                            else:
                                layer = QgsVectorLayer(path_layer,name) 
                                layer.loadNamedStyle(path_style)
                                project.addMapLayer(layer, False)
                                groupe.addLayer(layer)   
                                iface.mapCanvas().refresh()
                                self.dlg.textBrowser_3.append(name+" chargée")
                            
                    value += value_1
                    progressBar.setValue(value)
        
        
    def data_verification_dir_construction(self, data):
        """Verification du bon remplissage du champ Dossier du chantier de l'interface
         
        Entree:
            data : type str
            correspond au chemin d'accès du chantier
            
        Sortie:
            renvoie une erreur critique si les conditions ne sont pas remplies avec un message
        """
        if not data:
            iface.messageBar().pushMessage("Erreur", "Le champ du dossier de chantier est vide, il n'a pas été rempli", level=Qgis.Critical)
        else:
            if os.path.exists(data):
                self.dlg.textBrowser_3.append("Le chemin d'accès "+data+" est valide")
            else:
                iface.messageBar().pushMessage("Erreur", "Le chemin d'accès du dossier du chantier n'existe pas", level=Qgis.Critical)
                self.dlg.textBrowser_3.setTextColor(Color.RED.value)
                self.dlg.textBrowser_3.append("Erreur : le chemin d'accès du dossier chantier n'existe pas")
                self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
                
    def data_verification_dir(self, data):
        """Verification du bon remplissage des autres champs de l'interface
         
        Entree:
            data : type str
            correspond au chemin d'accès du dossier correspondant
            
        Sortie:
            renvoie une erreur critique si les conditions ne sont pas remplies avec un message
        """
        if not data[1]:
            text =  "Le champ du dossier "+data[0]+" est vide, il n'a pas été rempli"
            iface.messageBar().pushMessage("Erreur",text, level=Qgis.Warning)
            self.dlg.textBrowser_3.setTextColor(Color.RED.value)
            self.dlg.textBrowser_3.append( "Erreur : le champ du dossier "+data[0]+" est vide")
            self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
            return False
        else:
            if os.path.exists(data[1]):
                self.dlg.textBrowser_3.append("Le chemin d'accès "+data[0]+" est valide")
                return True
            else:
                self.dlg.textBrowser_3.setTextColor(Color.RED.value)
                self.dlg.textBrowser_3.append( "Erreur : le chemin d'accès du dossier "+os.path.basename(data[1])+" n'existe pas")
                self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
                return False
            
    def run_1(self):
        """Moteur de la partie creation d'un projet du plugin"""
        #progresse barre
        progressBar = self.dlg.progressBar
        value = 0
        progressBar.setValue(value)
        
        ### REMPLISSAGE DU FICHIER_CONFIGURATION_1 ###
        fichier_configuration_1 = os.path.normpath(self.dlg.lineEdit.text())
        try:
            with open(fichier_configuration_1): pass
        except IOError:
             iface.messageBar().pushMessage("Erreur", "Le fichier configuration n'est pas valide", level=Qgis.Critical)
        #initialisation de l'arbre du fichier .xml
        tree = etree.parse(os.path.join(fichier_configuration_1))
        root = tree.getroot()
    
        #parametres qui seront fournis par l'interface
        path_project = os.path.normpath(self.recovery_filename_project(root))
        path_carto_mondiale = self.recovery_path_SHP_Monde(root)
        path_dap = self.recovery_path_SHP_DAP(root)
        path_style = self.recovery_path_styleQGIS(root)
        path_construction = self.recovery_path_construction(root)
        
        if path_carto_mondiale != False:
            #Chemin valide = completion de l'import valide
            self.create_parametersFile_IMPORT(tree, root, path_carto_mondiale[1],"layers","layer_background" )
       
        if path_dap != False:
            #Chemin valide = completion de l'import valide
            self.create_parametersFile_IMPORT(tree, root, path_dap[1],"layers","layer_DAP" )
  
        if path_style != False:
            #Chemin valide = completion de l'import valide
            self.create_parametersFile_IMPORT(tree, root, path_style[1],"style", "styles" )
    
        if path_project == "":
            #Sinon, le projet est enregistre automatiquement à un endroit précis dans le dossier du chantier
            name_project = os.path.basename(path_construction)
            path_proj_relative= os.path.join("3_QUALIF_CALIX/QGIS", name_project)+".qgs"
            path_project = os.path.join(path_construction,path_proj_relative)
        #definition des couleurs des messages
       
        if path_construction != False:
            self.create_parametersFile_IMPORT(tree, root, path_construction,"layers", "layer" )

        #Verifications des entrees de l'utilisateur
        
        self.dlg.textBrowser_3.append( "CREATION D'UN PROJET")
       
            
        value = 15
        progressBar.setValue(value)

        #enregistrement sous un nouveau fichier parametre FIHCIER_CONFIGURATION_RESULTAT_1 
        name_project = os.path.basename(path_project).replace(".qgs","")
        tree.write(os.path.normpath(os.path.join(self.plugin_dir,"fichier_configuration_resultat_1.xml")))
        tree.write(os.path.join(os.path.dirname(path_project),"fichier_configuration_creation_projet_"+name_project+".xml"))
        self.dlg.textBrowser_3.setTextColor(Color.GREEN.value)
        self.dlg.textBrowser_3.append( "\nLe fichier_configuration_creation_projet est disponible dans le dossier "+os.path.dirname(path_project)+"\n")
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
        ### LECTURE DU FICHIER_CONFIGURATION_RESULTAT_1 ###
        tree = etree.parse(os.path.normpath(os.path.join(self.plugin_dir,"fichier_configuration_resultat_1.xml")))
        root = tree.getroot()
        
        #creation projet QGIS
      
        project = QgsProject.instance()
        color = QColor(166, 206, 227,255) #paramètre couleur fond projet en bleu
        project.setBackgroundColor(color)
        value = 50
        progressBar.setValue(value)
        #remplissage du journal de message du plugin
        self.dlg.textBrowser_3.setTextColor(Color.BLUE.value)
        self.dlg.textBrowser_3.append( "\nChargement des couches avec leur style :")
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
        self.loading_layers(tree, root, project,progressBar)
        
        #zoom sur l'reach du chantier
        for lyr in project.mapLayers().values():
            if lyr.name() == "reach_PU_CHANTIER":
                iface.mapCanvas().setExtent(lyr.extent())
        
        #recuperation du chemin d'enregistrement du projet dans le FICHIER_CONFIGURATION_RESULTAT_1
        filename_project = self.recovery_filename_project(root)
        
        #sauvegarde du projet
        if not os.path.exists(os.path.dirname(filename_project)):
                os.makedirs(os.path.dirname(filename_project))
        project.write(filename_project)
        value = 100
        progressBar.setValue(value)
        
        self.dlg.textBrowser_3.setTextColor(Color.GREEN.value)
        self.dlg.textBrowser_3.append( "\nLe projet est sauvegardé à l'emplacement :"+filename_project)
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
        pass
    
###############################EXPORT DES ILLUSTRATIONS#################################################
    ### SELECTION DES DONNEES EN ENTREE ###
    
    def select_input_fichier_configuration_2(self):
        fileconfig, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Fichier de configuration export des illustrations","",'(*.xml)')
        self.dlg.lineEdit_3.setText(fileconfig)
       
    def select_output_images(self):
        """Selection de l'emplacement du dossier illustrations"""
        directory_name = QFileDialog.getExistingDirectory(self.dlg)
        self.dlg.lineEdit_2.setText(directory_name)
        
    def select_definitive_output_images(self, root):
        output_img = root[0].find("path").text
        if output_img =="":
            output_img = self.dlg.lineEdit_2.text
            return output_img
        else:
            return output_img
        
    def find_grid(self,root, image):
        """Recupere la plus grande emprise des couches de l'illustration"""
        map_layer = image.find('map')
        area = 0
        reach = ""
        for layer in map_layer.findall('layer'):
            mapLayers = QgsProject.instance().mapLayersByName(layer.get('name'))
            if mapLayers!=[] and layer.get('name')!= "CARTO_MONDIALE" and layer.get('name')!= "ZONES_ARC" and layer.get('name')!= "ZONES_ARC_PU_CHANTIER" :
                layer_reach = QgsProject.instance().mapLayersByName(layer.get('name'))[0]  
                area_layer =  layer_reach.extent().area()
                if area_layer>area:
                    area = area_layer
                    reach = layer_reach.extent()
        return reach
     
    def filling_size_image(self, root):
        """Remplis la balise size du fichier configuration pour connaitre l'emprise de l'illustration"""
        for image in root[1].findall('image'):
            map_layer = image.find('map')
            reach = self.find_grid(root,image)
            size = map_layer.find('size')
            size.text = reach.toString() 
        return 
    
    
    def getMapLayers(self, image):
        """Recupere la liste des couches de l'illustration"""
        map_layer = image.find('map')
        layers = []
        for layer in map_layer.findall('layer'):
             if QgsProject.instance().mapLayersByName(layer.get('name'))!=[]:
                 layers.append(QgsProject.instance().mapLayersByName(layer.get('name'))[0])   
                 self.dlg.textBrowser_3.append(layer.get('name')+" CHARGEE")
        return layers
    
    def legende(self, layout, map):
        """Ajout d'une legende a l'illustration"""
        legend = QgsLayoutItemLegend(layout)
        legend.setLinkedMap(map) # pass a QgsLayoutItemMap object
        legend.setLegendFilterByMapEnabled(True)
        legend.refresh()     
        layout.addLayoutItem(legend)
        legend.attemptMove(QgsLayoutPoint(200,100,QgsUnitTypes.LayoutMillimeters))
    
    def title(self, layout,layoutName, map):
        """Ajout d'un titre a l'illustration"""
        title = QgsLayoutItemLabel(layout)
        title.setText(layoutName)
        title.setFont(QFont('Arial',16))
        title.adjustSizeToText()
        layout.addLayoutItem(title) # add the title to the layout
        title.attemptMove(QgsLayoutPoint(100,5,QgsUnitTypes.LayoutMillimeters))
    
    def scalebar(self, layout, map):
        """Ajout d'une echelle a l'illustration"""
        scalebar = QgsLayoutItemScaleBar(layout)
        
        scalebar.setStyle('Line Ticks Up') # let's people choose in the menu of the plugin for the next version
        
        scalebar.setUnits(QgsUnitTypes.DistanceKilometers)
        scalebar.setNumberOfSegments(4)
        scalebar.setNumberOfSegmentsLeft(0)
        scalebar.setUnitsPerSegment(150)
        scalebar.setLinkedMap(map)
        scalebar.setUnitLabel('km')
        scalebar.setFont(QFont('Arial',14))
       
        scalebar.update()
        layout.addLayoutItem(scalebar) # add the scalebar to the layout
        scalebar.attemptMove(QgsLayoutPoint(190,190,QgsUnitTypes.LayoutMillimeters))
    
    def export(self, root, path_img, progressBar):
        """Verifie quelle source satellite image a ete choisie par l'utilisateur"""
        
        #initialisation du projet ouvert/cree
        project = QgsProject().instance()
    
        #creation d'un manager de mise en page
        manager = project.layoutManager()
        #parcours les illustrations
        value_1 = 50/len(root[1].findall('image'))
        value = 50
        for image in root[1].findall('image'):
            layoutName = image.find('title').text
            layouts_list = manager.printLayouts()
            #supprime la mise en page si elle existe deja
            for layout in layouts_list:
                if layout.name() == layoutName:
                    manager.removeLayout(layout)
                    
            #creer la mise en page
            layout = QgsPrintLayout(project)
            layout.initializeDefaults()
            layout.setName(layoutName)
            
            #ajoute la mise en page à la liste des mises en page
            manager.addLayout(layout)
            
            #creation d'un emplacement carte dans la mise en page
            map = QgsLayoutItemMap(layout)
            map.setRect(20,20,20,20)
            
            #recuperation des couches pour l'illustration
            layers = self.getMapLayers(image)
           
                   
            #configuration de l'emplacement carte
            ms = QgsMapSettings()
            #ajout des couches à la carte
            ms.setLayers(layers) # set layers to be mapped
            map.setLayers(layers)
            #configurations :
            rect = QgsRectangle(ms.fullExtent())
            rect.scale(1.0)
            color = QColor(166, 206, 227,255)
            
            map_layer = image.find('map')
            #pour l'reach de l'image
            mini, maxi = map_layer.find('size').text.split(":")
            xmin, ymin = mini.split(",")
            xmax, ymax = maxi.split(",")
            reach = QgsRectangle(float(xmin)-3.0,float(ymin)-3.0,float(xmax)+3.0,float(ymax)+3.0)
            ms.setExtent(reach)
            ms.setBackgroundColor(color)
            map.setExtent(reach)
            
            #ajout de la carte à la mise en page
            layout.addLayoutItem(map) # add map to the layout
            
            map.attemptMove(QgsLayoutPoint(5,20,QgsUnitTypes.LayoutMillimeters))
            map.attemptResize(QgsLayoutSize(180,180,QgsUnitTypes.LayoutMillimeters))
          
            #ajout legende
            if image.find('legende').get('exist')=="yes":
                self.legende(layout, map)
            
            #ajout d'un titre 
            if image.find('title').get('exist')=="yes":
                self.title(layout,layoutName, map)
            
            #ajout d'une échelle
            if image.find('scale').get('exist')=="yes":
                self.scalebar(layout, map)
        
            
            # base_path = os.path.join(QgsProject.instance().homePath())
            pdf_path = os.path.join(path_img, layoutName+".png")

            exporter = QgsLayoutExporter(layout)
            exporter.exportToImage(pdf_path, QgsLayoutExporter.ImageExportSettings())
            for layer in layers:
                iface.setActiveLayer(layer)
            self.dlg.textBrowser_3.append("\n"+layoutName+" exportée")
            value+=value_1
            progressBar.setValue(value)
            
        
            
      
    def run_2(self):
        
        #progresse barre
        progressBar = self.dlg.progressBar_2
        value = 0
        progressBar.setValue(value)
       
        """PARTIE 2 : EXPORT DES ILLUSTRATIONS"""
        
        fichier_configuration_2 = os.path.normpath(self.dlg.lineEdit_3.text())
        try:
            with open(fichier_configuration_2): pass
        except IOError:
             iface.messageBar().pushMessage("Erreur", "Le fichier configuration n'est pas valide", level=Qgis.Critical)
        ### REMPLISSAGE DU FICHIER_CONFIGURATION_2 ###
        #initialisation de l'arbre du fichier .xml
        tree = etree.parse(fichier_configuration_2)
        root = tree.getroot()
       
        
        #remplissage du journal de messages du plugin
        #definition des couleurs des messages
        
        
        #Verifications des entrees de l'utilisateur
  
        self.dlg.textBrowser_3.append( "\nEXPORT DES ILLUSTRATIONS")
     
        self.dlg.textBrowser_3.setTextColor(Color.BLUE.value)
        self.dlg.textBrowser_3.append( "\nVérifications des données entrées :")
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
    
        
        #verifications des entrees de l'utilisateur
        path_img = self.select_definitive_output_images(root)

        value = 15
        progressBar.setValue(value)
        name_project = os.path.basename(QgsProject.instance().fileName()).replace(".qgs","")
        path_project = QgsProject.instance().fileName()
        if self.data_verification_dir(path_img)==True:
            #Chemin valide = completion de l'import valide
            self.create_configuration_2_PARAMETERS(tree, root, name_project, path_project, path_img[1])
            path_img = path_img[1]
        else : 
            if "3_QUALIF_CALIX" in path_project:
                path_img = os.path.normpath(os.path.join(os.path.dirname(os.path.dirname(path_project)), "ILLUSTRATIONS"))
            else:
                path_img = os.path.normpath(os.path.join(os.path.dirname(path_project), "ILLUSTRATIONS"+name_project))
                if not os.path.exists(path_img):
                    os.makedirs(path_img)
            
            
        self.filling_size_image(root)
        #enregistrement sous un nouveau fichier parametre FIHCIER_CONFIGURATION_RESULTAT_2 
        tree.write(os.path.join(self.plugin_dir,"fichier_configuration_resultat_2.xml"))
        tree.write(os.path.join(path_img,"fichier_configuration_export_"+name_project+".xml"))
        value = 50
        progressBar.setValue(value)
        #messages
        self.dlg.textBrowser_3.setTextColor(Color.GREEN.value)
        self.dlg.textBrowser_3.append( "\nLe fichier_configuration_export est disponible dans le dossier "+path_img)
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
        
        ### LECTURE DU FICHIER_CONFIGURATION_2 ###
        self.dlg.textBrowser_3.setTextColor(Color.BLUE.value)
        self.dlg.textBrowser_3.append( "\nExport des illustrations :")
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
        self.export(root, path_img, progressBar)
        self.dlg.textBrowser_3.setTextColor(Color.GREEN.value)
        self.dlg.textBrowser_3.append( "\nLes illustrations sont disponibles dans le dossier "+path_img)
        self.dlg.textBrowser_3.setTextColor(Color.BLACK.value)
    
        
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = CreationExportV2Dialog()
            ###PREMIERE PARTIE DU PLUGIN : CREATION D'UN PROJET###
            self.dlg.pushButton.clicked.connect(self.select_input_fichier_configuration_1)
            self.dlg.pushButton_1.clicked.connect(self.select_output_project)
            
            
            self.dlg.pushButton_3.clicked.connect(self.run_1)
            ###DEUXIEME PARTIE DU PLUGIN : EXPORT DES ILLUSTRATIONS###
            #pre-remplissage de la zone texte export
            name_project = os.path.basename(QgsProject.instance().fileName()).replace(".qgs","")
            path_project = os.path.normpath(os.path.join(os.path.dirname(QgsProject.instance().fileName()),name_project+"_ILLUSTRATIONS"))
           
            self.dlg.lineEdit_3.setText(path_project)
            self.dlg.pushButton_2.clicked.connect(self.select_output_images)
            self.dlg.pushButton_5.clicked.connect(self.select_input_fichier_configuration_2)

            self.dlg.pushButton_4.clicked.connect(self.run_2)
        # show the dialog
        self.dlg.show()
       
